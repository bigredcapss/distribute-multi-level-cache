# 分布式多级缓存框架 - 使用说明书

## 目录

1. [快速开始](#快速开始)
2. [依赖引入](#依赖引入)
3. [基础配置](#基础配置)
4. [使用方式](#使用方式)
5. [高级功能](#高级功能)
6. [配置详解](#配置详解)
7. [最佳实践](#最佳实践)
8. [常见问题](#常见问题)

---

## 快速开始

### 5分钟快速接入

1. **添加依赖**（见下方）
2. **配置 Redis 连接**
3. **配置缓存**
4. **启用缓存注解**
5. **使用 `@Cacheable` 注解**

---

## 依赖引入

### Maven 项目

在 `pom.xml` 中添加依赖：

```xml
<dependency>
    <groupId>com.peanut.infra</groupId>
    <artifactId>infra-multi-level-cache</artifactId>
    <version>1.0.0-SNAPSHOT</version>
</dependency>
```

### Gradle 项目

在 `build.gradle` 中添加：

```gradle
dependencies {
    implementation 'com.peanut.infra:infra-multi-level-cache:1.0.0-SNAPSHOT'
}
```

### 前置依赖

框架会自动引入以下依赖（无需手动添加）：
- Spring Boot 2.4.0+
- Spring Data Redis
- Caffeine 2.8.5
- Lettuce 6.0.1

---

## 基础配置

### 1. 启用缓存注解

在启动类上添加 `@EnableCaching` 注解：

```java
@EnableCaching
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### 2. 配置 Redis 连接

在 `application.yml` 或 `application.properties` 中配置 Redis：

**YAML 格式：**
```yaml
spring:
  redis:
    host: localhost
    port: 6379
    password: your-password  # 可选
    database: 0
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: -1
```

**Properties 格式：**
```properties
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.password=your-password
spring.redis.database=0
spring.redis.lettuce.pool.max-active=8
spring.redis.lettuce.pool.max-idle=8
spring.redis.lettuce.pool.min-idle=0
spring.redis.lettuce.pool.max-wait=-1
```

### 3. 配置缓存

框架支持三种缓存模式：

#### 模式一：仅使用 Caffeine（本地缓存）

```yaml
multiple-cache:
  caffeine:
    - name: userCache
      expireAfterAccess: 3600  # 访问后过期时间（秒）
      maximumSize: 1000         # 最大容量
      initialCapacity: 100      # 初始容量
```

#### 模式二：仅使用 Redis（分布式缓存）

```yaml
multiple-cache:
  redis:
    - name: userCache
      expire: 3600  # 过期时间（秒）
```

#### 模式三：Caffeine + Redis（多级缓存，推荐）

```yaml
multiple-cache:
  multiple:
    - name: userCache
      caffeine:
        expireAfterAccess: 30   # Caffeine 访问后过期时间（秒）
        initialCapacity: 100
        maximumSize: 1000
        disableSync: false       # 开启同步（多节点部署时）
      redis:
        expire: 3600             # Redis 过期时间（秒）
```

---

## 使用方式

### 1. 使用 Spring Cache 注解

框架完全兼容 Spring Cache 注解，可以直接使用：

#### @Cacheable - 缓存查询

```java
@Service
public class UserService {
    
    @Cacheable(cacheNames = "userCache", key = "#id")
    public User getUserById(String id) {
        // 业务逻辑：从数据库查询用户
        return userRepository.findById(id);
    }
    
    @Cacheable(cacheNames = "userCache", key = "#user.id", condition = "#user != null")
    public User getUser(User user) {
        return userRepository.findById(user.getId());
    }
}
```

#### @CacheEvict - 缓存删除

```java
@Service
public class UserService {
    
    @CacheEvict(cacheNames = "userCache", key = "#id")
    public void deleteUser(String id) {
        userRepository.deleteById(id);
    }
    
    // 清空整个缓存
    @CacheEvict(cacheNames = "userCache", allEntries = true)
    public void clearUserCache() {
        // 业务逻辑
    }
}
```

#### @CachePut - 更新缓存

```java
@Service
public class UserService {
    
    @CachePut(cacheNames = "userCache", key = "#user.id")
    public User updateUser(User user) {
        return userRepository.save(user);
    }
}
```

#### @Caching - 组合多个缓存操作

```java
@Service
public class UserService {
    
    @Caching(
        evict = {
            @CacheEvict(cacheNames = "userCache", key = "#user.id"),
            @CacheEvict(cacheNames = "userListCache", allEntries = true)
        },
        put = @CachePut(cacheNames = "userCache", key = "#result.id")
    )
    public User updateUser(User user) {
        return userRepository.save(user);
    }
}
```

### 2. 编程式使用 CacheManager

```java
@Service
public class UserService {
    
    @Autowired
    private CacheManager cacheManager;
    
    public void manualCache() {
        Cache cache = cacheManager.getCache("userCache");
        
        // 写入缓存
        cache.put("key1", new User("1", "张三"));
        
        // 读取缓存
        Cache.ValueWrapper wrapper = cache.get("key1");
        if (wrapper != null) {
            User user = (User) wrapper.get();
        }
        
        // 删除缓存
        cache.evict("key1");
        
        // 清空缓存
        cache.clear();
    }
}
```

### 3. 多级缓存工作原理

在多级缓存（Caffeine + Redis）模式下：

**查询流程：**
```
1. 先查 Caffeine（本地缓存，最快）
   ├── 命中 → 直接返回
   └── 未命中 → 继续
2. 再查 Redis（分布式缓存）
   ├── 命中 → 回填 Caffeine → 返回
   └── 未命中 → 继续
3. 执行业务逻辑（如查询数据库）
4. 写入 Redis → 写入 Caffeine → 返回
```

**写入流程：**
```
1. 先写入 Redis（保证分布式一致性）
2. 再写入 Caffeine（提升本地性能）
3. 发布同步事件（通知其他节点更新本地缓存）
```

---

## 高级功能

### 1. 缓存值重建器（CachedValueRebuilder）

当需要从缓存中读取数据后进行转换时，可以使用值重建器。

**使用场景：**
- 缓存中存储的是 `User` 对象，读取时需要转换为 `VIPUser`
- 缓存中存储的是旧版本数据，需要升级为新版本
- 需要根据缓存值动态计算衍生数据

**实现步骤：**

1. 实现 `CachedValueRebuilder` 接口：

```java
@Component
public class UserValueRebuilder implements CachedValueRebuilder<String, Object> {
    
    @Override
    public Object rebuild(String key, Object value) {
        if (value instanceof User) {
            User user = (User) value;
            // 转换为 VIPUser
            VIPUser vipUser = new VIPUser();
            BeanUtils.copyProperties(user, vipUser);
            vipUser.setLevel(calculateLevel(user));
            return vipUser;
        }
        return value;
    }
    
    private int calculateLevel(User user) {
        // 计算 VIP 等级
        return user.getScore() / 1000;
    }
}
```

2. 在配置中引用：

```yaml
multiple-cache:
  multiple:
    - name: userCache
      decorators: userValueRebuilder  # Bean 名称（首字母小写）
      caffeine:
        expireAfterAccess: 30
        maximumSize: 1000
      redis:
        expire: 3600
```

### 2. 自定义缓存策略（CacheStrategy）

当需要自定义缓存的序列化、压缩、加密等逻辑时，可以使用自定义策略。

**实现步骤：**

1. 实现缓存策略接口：

```java
// Redis 缓存策略
@Component("customRedisCacheStrategy")
public class CustomRedisCacheStrategy extends AbstractRedisCacheStrategy {
    
    public CustomRedisCacheStrategy(String cacheName) {
        super(cacheName);
    }
    
    @Override
    public Object doGet(Object nativeCache, Object key) {
        // 自定义获取逻辑
        RedisCacheWriter writer = (RedisCacheWriter) nativeCache;
        byte[] value = writer.get(getCacheName(), serializeKey(key));
        if (value != null) {
            // 自定义反序列化、解密等
            return deserialize(value);
        }
        return null;
    }
    
    @Override
    public boolean doPut(Object nativeCache, Object key, Object value) {
        // 自定义写入逻辑
        RedisCacheWriter writer = (RedisCacheWriter) nativeCache;
        byte[] serializedValue = serialize(value);
        writer.put(getCacheName(), serializeKey(key), serializedValue);
        return true;
    }
    
    private byte[] serialize(Object obj) {
        // 自定义序列化逻辑
        return JSON.toJSONBytes(obj);
    }
    
    private Object deserialize(byte[] data) {
        // 自定义反序列化逻辑
        return JSON.parseObject(data, Object.class);
    }
}
```

2. 在配置中引用：

```yaml
multiple-cache:
  redis:
    - name: userCache
      strategy: customRedisCacheStrategy  # Bean 名称
      expire: 3600
```

### 3. 缓存同步机制

在多节点部署场景下，当某个节点更新了本地 Caffeine 缓存时，需要通知其他节点更新本地缓存。

**配置方式：**

```yaml
multiple-cache:
  multiple:
    - name: userCache
      caffeine:
        disableSync: false  # 开启同步（默认 true，即不开启）
        expireAfterAccess: 30
        maximumSize: 1000
      redis:
        expire: 3600
```

**工作原理：**
```
节点A: cache.put(key, value)
  ↓
CacheSyncDecorator 拦截
  ↓
发布 PutEvent 到 Redis Channel
  ↓
节点B、C...: 接收消息
  ↓
更新本地 Caffeine 缓存
```

**注意事项：**
- 只有 Caffeine 缓存需要同步（Redis 是共享的）
- 同步基于 Redis Pub/Sub，存在网络延迟，非强一致性
- 建议在高并发写场景下谨慎使用，避免消息风暴

### 4. 缓存加载器（CacheLoader）

当缓存未命中时，可以自动从数据源加载数据。

**实现步骤：**

1. 实现 `CacheLoader` 接口：

```java
@Component
public class UserCacheLoader implements CacheLoader<Object, Object> {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public Object load(Object key) throws Exception {
        // 从数据库加载数据
        return userRepository.findById((String) key);
    }
    
    @Override
    public Map<Object, Object> loadAll(Iterable<?> keys) throws Exception {
        // 批量加载
        List<String> ids = StreamSupport.stream(keys.spliterator(), false)
            .map(Object::toString)
            .collect(Collectors.toList());
        return userRepository.findByIds(ids);
    }
}
```

2. 在配置中引用：

```yaml
multiple-cache:
  caffeine:
    - name: userCache
      cacheLoader: userCacheLoader  # Bean 名称
      expireAfterAccess: 30
      maximumSize: 1000
```

---

## 配置详解

### Caffeine 缓存配置

| 配置项 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `name` | String | - | 缓存名称（必填） |
| `expireAfterAccess` | long | 3600 | 访问后过期时间（秒） |
| `expireAfterWrite` | long | 0 | 写入后过期时间（秒）<br>优先级高于 `expireAfterAccess` |
| `maximumSize` | int | 200 | 最大容量（条目数） |
| `initialCapacity` | int | 10 | 初始容量 |
| `cacheLoader` | String | - | 缓存加载器 Bean 名称 |
| `decorators` | String | - | 装饰器 Bean 名称（逗号分隔） |
| `disableSync` | boolean | true | 是否禁用同步<br>`false` 表示开启同步 |
| `enableSoftRef` | boolean | false | 是否启用软引用<br>启用后可在内存不足时被 GC |
| `strategy` | String | - | 缓存策略 Bean 名称 |

**配置示例：**

```yaml
multiple-cache:
  caffeine:
    - name: userCache
      expireAfterAccess: 3600      # 1小时未访问则过期
      maximumSize: 10000          # 最多缓存10000条
      initialCapacity: 100        # 初始容量100
      disableSync: false          # 开启同步
      enableSoftRef: true         # 启用软引用
```

### Redis 缓存配置

| 配置项 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `name` | String | - | 缓存名称（必填） |
| `expire` | long | - | 过期时间（秒，必填） |
| `strategy` | String | - | 缓存策略 Bean 名称 |
| `decorators` | String | - | 装饰器 Bean 名称（逗号分隔） |

**配置示例：**

```yaml
multiple-cache:
  redis:
    - name: userCache
      expire: 7200  # 2小时过期
      strategy: customRedisCacheStrategy
```

### 多级缓存配置

| 配置项 | 类型 | 说明 |
|--------|------|------|
| `name` | String | 缓存名称（必填） |
| `caffeine` | Object | Caffeine 配置（参考上方） |
| `redis` | Object | Redis 配置（参考上方） |
| `decorators` | String | 装饰器 Bean 名称（逗号分隔） |

**配置示例：**

```yaml
multiple-cache:
  multiple:
    - name: userCache
      caffeine:
        expireAfterAccess: 30
        maximumSize: 1000
        disableSync: false
      redis:
        expire: 3600
      decorators: userValueRebuilder
```

### 完整配置示例

```yaml
spring:
  application:
    name: my-application
  redis:
    host: localhost
    port: 6379
    password: your-password
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0

multiple-cache:
  # 多级缓存配置（推荐）
  multiple:
    - name: userCache
      caffeine:
        expireAfterAccess: 30
        maximumSize: 1000
        initialCapacity: 100
        disableSync: false
      redis:
        expire: 3600
      decorators: userValueRebuilder
    
    - name: productCache
      caffeine:
        expireAfterAccess: 60
        maximumSize: 5000
      redis:
        expire: 7200
  
  # 仅 Caffeine 缓存
  caffeine:
    - name: localCache
      expireAfterAccess: 300
      maximumSize: 500
  
  # 仅 Redis 缓存
  redis:
    - name: sharedCache
      expire: 1800
```

---

## 最佳实践

### 1. 缓存命名规范

- 使用有意义的缓存名称，如 `userCache`、`productCache`
- 避免使用特殊字符，建议使用驼峰命名
- 同一业务模块使用统一的前缀，如 `user:info`、`user:list`

### 2. Key 设计原则

- **唯一性**：确保 key 唯一标识缓存数据
- **可读性**：使用有意义的 key，便于调试
- **简洁性**：避免过长的 key，节省内存

```java
// 推荐
@Cacheable(cacheNames = "userCache", key = "#id")
public User getUserById(String id) { ... }

// 推荐：组合 key
@Cacheable(cacheNames = "userCache", key = "#userId + ':' + #type")
public User getUser(String userId, String type) { ... }

// 不推荐：key 过长
@Cacheable(cacheNames = "userCache", key = "#user.id + ':' + #user.name + ':' + #user.email")
```

### 3. 过期时间设置

- **Caffeine**：建议设置较短的过期时间（30秒-5分钟），用于热点数据
- **Redis**：建议设置较长的过期时间（1小时-24小时），用于持久化数据
- **多级缓存**：Caffeine 过期时间 < Redis 过期时间

```yaml
multiple-cache:
  multiple:
    - name: userCache
      caffeine:
        expireAfterAccess: 30   # 30秒（热点数据）
      redis:
        expire: 3600            # 1小时（持久化）
```

### 4. 容量设置

根据业务场景合理设置容量：

```yaml
# 高频访问的小数据量缓存
caffeine:
  - name: configCache
    maximumSize: 100      # 配置数据量小

# 中频访问的中等数据量缓存
caffeine:
  - name: userCache
    maximumSize: 10000    # 用户数据量中等

# 低频访问的大数据量缓存
caffeine:
  - name: productCache
    maximumSize: 100000   # 商品数据量大
```

### 5. 缓存穿透防护

框架未提供默认的穿透防护，建议在业务层实现：

```java
@Service
public class UserService {
    
    @Cacheable(cacheNames = "userCache", key = "#id")
    public User getUserById(String id) {
        User user = userRepository.findById(id);
        if (user == null) {
            // 缓存空值，避免穿透
            cacheManager.getCache("userCache").put(id, new NullUser());
            throw new UserNotFoundException("用户不存在");
        }
        return user;
    }
}
```

### 6. 缓存雪崩防护

设置随机过期时间，避免大量缓存同时过期：

```java
@Service
public class UserService {
    
    @Cacheable(cacheNames = "userCache", key = "#id")
    public User getUserById(String id) {
        // 业务逻辑
    }
    
    // 在配置中使用随机过期时间
    // 或通过自定义策略实现
}
```

### 7. 多节点部署

在多节点部署场景下：

- **开启同步**：设置 `disableSync: false`
- **合理设置过期时间**：Caffeine 过期时间应小于 Redis
- **监控同步消息**：关注 Redis Pub/Sub 的消息量

```yaml
multiple-cache:
  multiple:
    - name: userCache
      caffeine:
        disableSync: false  # 多节点部署必须开启
        expireAfterAccess: 30
      redis:
        expire: 3600
```

### 8. 性能优化建议

1. **合理使用多级缓存**：热点数据使用 Caffeine + Redis，冷数据仅使用 Redis
2. **避免缓存大对象**：大对象会占用大量内存，影响性能
3. **使用缓存加载器**：减少缓存未命中时的数据库查询
4. **监控缓存命中率**：通过 Caffeine 的统计功能监控命中率

---

## 常见问题

### Q1: 如何只使用 Caffeine 缓存？

**A**: 只配置 `multiple-cache.caffeine`，不配置 `multiple-cache.redis` 和 `multiple-cache.multiple`。

```yaml
multiple-cache:
  caffeine:
    - name: localCache
      expireAfterAccess: 300
      maximumSize: 1000
```

### Q2: 如何只使用 Redis 缓存？

**A**: 只配置 `multiple-cache.redis`，不配置其他缓存类型。

```yaml
multiple-cache:
  redis:
    - name: sharedCache
      expire: 3600
```

### Q3: 缓存不生效怎么办？

**A**: 检查以下几点：

1. **是否启用了缓存注解**：确保启动类上有 `@EnableCaching`
2. **缓存名称是否匹配**：`@Cacheable` 的 `cacheNames` 必须与配置中的 `name` 一致
3. **方法是否被代理**：确保方法在 Spring 管理的 Bean 中，且被外部调用
4. **条件是否满足**：检查 `@Cacheable` 的 `condition` 条件

### Q4: 缓存同步不生效？

**A**: 检查以下几点：

1. **是否开启同步**：`disableSync` 必须设置为 `false`
2. **Redis 连接是否正常**：检查 Redis 连接配置
3. **应用名称是否一致**：确保所有节点的 `spring.application.name` 一致
4. **查看日志**：检查是否有同步消息发送/接收的日志

### Q5: 如何自定义序列化方式？

**A**: 实现自定义的 `CacheStrategy`：

```java
@Component("customRedisCacheStrategy")
public class CustomRedisCacheStrategy extends AbstractRedisCacheStrategy {
    // 实现自定义序列化逻辑
}
```

### Q6: 如何监控缓存命中率？

**A**: Caffeine 提供了统计功能，可以通过 `getNativeCache()` 获取统计信息：

```java
@Autowired
private CacheManager cacheManager;

public void printStats() {
    Cache cache = cacheManager.getCache("userCache");
    if (cache != null) {
        com.github.benmanes.caffeine.cache.Cache nativeCache = 
            (com.github.benmanes.caffeine.cache.Cache) cache.getNativeCache();
        com.github.benmanes.caffeine.cache.stats.CacheStats stats = nativeCache.stats();
        System.out.println("命中率: " + stats.hitRate());
        System.out.println("命中次数: " + stats.hitCount());
        System.out.println("未命中次数: " + stats.missCount());
    }
}
```

### Q7: 如何清空所有缓存？

**A**: 通过 `CacheManager` 清空：

```java
@Autowired
private CacheManager cacheManager;

public void clearAllCaches() {
    cacheManager.getCacheNames().forEach(name -> {
        Cache cache = cacheManager.getCache(name);
        if (cache != null) {
            cache.clear();
        }
    });
}
```

### Q8: 缓存对象需要实现 Serializable 吗？

**A**: 
- **Redis 缓存**：需要实现 `Serializable` 或使用 Jackson 注解（框架默认使用 Jackson）
- **Caffeine 缓存**：不需要实现 `Serializable`

### Q9: 如何避免缓存穿透？

**A**: 在业务层缓存空值：

```java
@Cacheable(cacheNames = "userCache", key = "#id")
public User getUserById(String id) {
    User user = userRepository.findById(id);
    if (user == null) {
        // 缓存空值，设置较短的过期时间
        cacheManager.getCache("userCache").put(id, new NullUser());
        return null;
    }
    return user;
}
```

### Q10: 多级缓存的数据一致性如何保证？

**A**: 
- **写入时**：先写 Redis，再写 Caffeine，保证数据一致性
- **同步时**：通过 Redis Pub/Sub 通知其他节点更新本地缓存
- **注意**：同步存在网络延迟，非强一致性，对一致性要求高的场景建议只使用 Redis

---

## 示例代码

### 完整示例

**1. 启动类**

```java
@EnableCaching
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

**2. 配置文件（application.yml）**

```yaml
spring:
  application:
    name: my-application
  redis:
    host: localhost
    port: 6379
    lettuce:
      pool:
        max-active: 8

multiple-cache:
  multiple:
    - name: userCache
      caffeine:
        expireAfterAccess: 30
        maximumSize: 1000
        disableSync: false
      redis:
        expire: 3600
```

**3. Service 类**

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Cacheable(cacheNames = "userCache", key = "#id")
    public User getUserById(String id) {
        return userRepository.findById(id);
    }
    
    @CacheEvict(cacheNames = "userCache", key = "#id")
    public void deleteUser(String id) {
        userRepository.deleteById(id);
    }
    
    @CachePut(cacheNames = "userCache", key = "#user.id")
    public User updateUser(User user) {
        return userRepository.save(user);
    }
}
```

**4. Controller 类**

```java
@RestController
@RequestMapping("/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable String id) {
        return userService.getUserById(id);
    }
    
    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable String id) {
        userService.deleteUser(id);
    }
}
```

---

## 技术支持

如有问题，请参考：
- [项目说明书](README.md) - 了解框架架构和设计
- 示例代码：`infra-multi-level-cache-example` 模块

---

**文档版本**: v1.0  
**最后更新**: 2025年  
**作者**: peanut

